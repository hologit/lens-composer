#!/bin/node --inspect-brk=0.0.0.0:9229

const { Repo } = require('hologit');
const TOML = require('@iarna/toml');
const fs = require('mz/fs');
const path = require('path');
const glob = require('mz-modules/glob');
const execa = require('execa');


outputResult(lensTree(process.argv[2]));

async function lensTree(treeHash) {

    // load env/input
    const repo = await Repo.getFromEnvironment();
    const git = await repo.getGit();
    const tree = await repo.createTreeFromRef(treeHash);
    const requiresTree = await tree.getChild('composer-requires');


    // init output
    const outputTree = repo.createTree();


    // check env/input
    if (!requiresTree) {
        return outputTree;
    }

    if (!requiresTree.isTree) {
        throw new Error('./composer-requires must be a tree');
    }


    // extract definitions from tree
    const composerRequire = {};
    const requiresChildren = await requiresTree.getBlobMap();
    const childPathRe = /^(?<vendor>[^/]+)\/(?<project>[^.]+).toml$/;

    for (const childPath in requiresChildren) {
        const childPathMatch = childPathRe.exec(childPath);
        if (!childPathMatch) {
            console.error(`${childPath} does not match <vendor>/<project>.toml`);
            continue;
        }

        const { vendor, project } = childPathMatch.groups;

        let parsed;
        try {
            parsed = TOML.parse(await requiresChildren[childPath].read());
        } catch (err) {
            throw new Error(`could not parse ${childPath}: ${err.message}`);
        }

        const spec = parsed['composer-requires'];
        if (!spec) {
            throw new Error(`${childPath} does not contain [composer-requires] table`);
        }

        if (!spec.vendor) {
            spec.vendor = vendor;
        }

        if (!spec.project) {
            spec.project = project;
        }

        composerRequire[`${spec.vendor}/${spec.project}`] = spec.version;
    }


    // delete anything on disk and not in index
    console.error('Cleaning working tree');
    await git.clean({ d: true, force: true });


    // generate composer manifest
    console.error('Generating composer.json');
    await fs.writeFile('composer.json', Buffer.from(JSON.stringify({ require: composerRequire })));


    // use composer to resolve and install dependencies
    console.error('Running composer install');
    let composerExitCode;
    try {
        const composerProcess = execa('composer', [
            'install',
            // '--no-autoloader',
            '--no-interaction',
            '--no-progress',
            '--no-scripts',
            '--no-dev',
            '--no-suggest',
            // '--prefer-source',
            '--classmap-authoritative'
        ], {
            env: {
                COMPOSER_ALLOW_SUPERUSER: true
            }
        });
        composerProcess.stderr.pipe(process.stderr);
        composerProcess.stdout.pipe(process.stderr);
        ({ exitCode: composerExitCode } = await composerProcess);
    } catch (err) {
        console.error(`Composer install failed: ${err.message}`);
        process.exit(1);
    }

    if (composerExitCode !== 0) {
        console.error(`composer install failed with code ${composerExitCode}`);
        process.exit(exitCode);
    }


    // read classes and bootstrap files from generated autoload files
    console.error('Reading composer manifests');
    const { stdout: composerOutputJson } = await execa('php', [
        '-r',
        `
            echo json_encode([
                'classmap' => require('vendor/composer/autoload_classmap.php'),
                'files' => require('vendor/composer/autoload_files.php')
            ]);
        `
    ]);
    const composerOutput = JSON.parse(composerOutputJson);


    // build outputTree
    const writePromises = [];


    // write PHP classes and build list of paths to exclude from bootstraps tree
    const vendorClassFilePaths = new Set();
    console.error('Populating php-classes/');
    for (const className in composerOutput.classmap) {
        const classFilePath = composerOutput.classmap[className];
        vendorClassFilePaths.add(classFilePath);

        writePromises.push(
            repo.writeBlobFromFile(classFilePath)
                .then(blob => outputTree.writeChild(`php-classes/${className.replace(/\\/g, '/')}.php`, blob))
        );
    }


    // copy all non-class PHP files into php-bootstraps/composer-requires
    console.error('Populating php-bootstraps/');
    const miscPhpFiles = await glob(`${process.cwd()}/vendor/*/**/*.php`, { nodir: true, ignore: ['**/bin/**','**/tests/**'] });
    for (const filePath of miscPhpFiles) {
        if (vendorClassFilePaths.has(filePath)) {
            continue;
        }

        const fileRelPath = path.relative('./vendor', filePath);
        writePromises.push(
            repo.writeBlobFromFile(filePath)
                .then(blob => outputTree.writeChild(`php-bootstraps/composer-requires/${fileRelPath}`, blob))
        );
    }


    // write PHP bootstrap files
    console.error('Generating php-bootstraps/composer-requires.php');
    const loaderCodeLines = ['<?php'];
    for (const bootstrapHash in composerOutput.files) {
        const fileRelPath = path.relative('./vendor', composerOutput.files[bootstrapHash]);
        loaderCodeLines.push(`require_once __DIR__.'/composer-requires/${fileRelPath}';`);
    }

    writePromises.push(
        repo.writeBlob(loaderCodeLines.join('\n'))
            .then(blob => outputTree.writeChild(`php-bootstraps/composer-requires.php`, blob))
    );


    // wait for all writes to finish
    await Promise.all(writePromises);


    return outputTree;
}


async function outputResult(result) {
    result = await result;

    if (result.isTree) {
        const treeHash = await result.write();
        console.error(`\n\nFinished building tree: ${treeHash}`);
        console.log(treeHash);
        process.exit(0);
        return;
    }

    console.error('no result');
    process.exit(1);
}



// To merge with another (base?) composor.json file, use a format like this:
// {
//     "require": {
//         "wikimedia/composer-merge-plugin": "dev-master"
//     },
//     "extra": {
//         "merge-plugin": {
//             "include": [
//                 "composer.local.json",
//                 "extensions/*/composer.json"
//             ],
//             "require": [
//                 "submodule/composer.json"
//             ],
//             "recurse": true,
//             "replace": false,
//             "ignore-duplicates": false,
//             "merge-dev": true,
//             "merge-extra": false,
//             "merge-extra-deep": false,
//             "merge-scripts": false
//         }
//     }
// }